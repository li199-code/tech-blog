---
title: "Go 结构体数据类型"
slug: "go -jie-gou-ti-shu-ju-lei-xing"
date: 2024-10-26
description: "generated by ai"
tags: [Go]
---

在 Go 语言中，**在 Go 语言中，`struct`（结构体）** 是一种复合数据类型，它将多个不同类型的数据组合在一起，形成一个更复杂的数据类型。每个字段都有自己的名字和类型。`struct` 是 Go 中非常重要的数据结构，类似于面向对象编程中的类（class），但 Go 不支持传统的继承概念。

<!-- truncate -->

### **定义结构体**

使用 `type` 关键字来定义结构体，并在结构体中声明字段及其类型。

#### 语法：

```go
type StructName struct {
    Field1 FieldType1
    Field2 FieldType2
    // 可以包含任意数量的字段
}
```

#### 示例：

```go
type Person struct {
    Name string
    Age  int
}
```

在这个例子中，`Person` 是一个结构体类型，包含两个字段：`Name` 是 `string` 类型，`Age` 是 `int` 类型。

### **创建结构体实例**

可以通过以下几种方式来创建结构体的实例：

#### a. 直接创建

```go
var p Person
p.Name = "Alice"
p.Age = 30
```

#### b. 使用字面量（struct literal）

```go
p := Person{Name: "Alice", Age: 30}
```

也可以省略字段名，但这种方式依赖字段的声明顺序，使用时要特别小心。

```go
p := Person{"Alice", 30}
```

#### c. 使用指针创建

可以直接用 `&` 获取结构体的指针，并通过指针引用来访问字段。

```go
p := &Person{Name: "Bob", Age: 25}
fmt.Println(p.Name) // 输出: Bob
```

### **访问结构体字段**

使用点号 `.` 来访问结构体的字段：

```go
fmt.Println(p.Name) // 输出: Alice
fmt.Println(p.Age)  // 输出: 30
```

如果是结构体指针，也可以通过 `.` 操作符直接访问字段，Go 会自动解引用指针。

```go
p := &Person{Name: "Charlie", Age: 22}
fmt.Println(p.Name) // 自动解引用，输出: Charlie
```

### **匿名字段**

Go 允许在结构体中定义**匿名字段** （embedded fields），也称为嵌入式字段，字段名为其类型名。

#### 示例：

```go
type Address struct {
    City, State string
}

type Person struct {
    Name string
    Age  int
    Address // 匿名字段，类型名为字段名
}
```

在这里，`Address` 结构体嵌入到了 `Person` 结构体中，`Person` 的实例可以直接访问 `Address` 的字段：

```go
p := Person{
    Name: "Alice",
    Age:  30,
    Address: Address{
        City:  "New York",
        State: "NY",
    },
}
fmt.Println(p.City)  // 输出: New York
fmt.Println(p.State) // 输出: NY
```

### **结构体方法**

Go 支持为结构体定义方法，方法和普通函数的区别是，方法有一个**接收者** （receiver），接收者可以是值类型或指针类型。

#### a. 值类型接收者

```go
func (p Person) Greet() {
    fmt.Printf("Hello, my name is %s\n", p.Name)
}
```

使用时：

```go
p := Person{Name: "Alice", Age: 30}
p.Greet() // 输出: Hello, my name is Alice
```

#### b. 指针类型接收者

如果你需要在方法中修改结构体的字段，接收者必须是指针类型。

```go
func (p *Person) SetAge(newAge int) {
    p.Age = newAge
}
```

使用时：

```go
p := &Person{Name: "Alice", Age: 30}
p.SetAge(35)
fmt.Println(p.Age) // 输出: 35
```

### **结构体的零值**

Go 语言的结构体是有默认零值的。所有字段会被初始化为该字段类型的零值：

- 数字类型：`0`

- 字符串：空字符串 `""`

- 布尔值：`false`

- 指针、切片、映射、通道：`nil`

例如：

```go
var p Person
fmt.Println(p.Name) // 输出: 空字符串
fmt.Println(p.Age)  // 输出: 0
```

### **结构体比较**

Go 语言中的结构体支持比较运算符 `==` 和 `!=`，但所有字段都必须是可比较的类型，且只有当两个结构体的字段值完全相同时，两个结构体才相等。

#### 示例：

```go
p1 := Person{Name: "Alice", Age: 30}
p2 := Person{Name: "Alice", Age: 30}

fmt.Println(p1 == p2) // 输出: true
```

### **结构体作为函数参数**

结构体可以作为函数的参数，传递方式可以是**值传递** 或者**引用传递** （指针）。

#### a. 值传递

```go
func ChangeName(p Person) {
    p.Name = "Bob"
}

p := Person{Name: "Alice"}
ChangeName(p)
fmt.Println(p.Name) // 输出: Alice
```

此时，结构体以值传递方式传入，`ChangeName` 函数中的修改不会影响外部的 `p`。

#### b. 引用传递

```go
func ChangeName(p *Person) {
    p.Name = "Bob"
}

p := Person{Name: "Alice"}
ChangeName(&p)
fmt.Println(p.Name) // 输出: Bob
```

使用指针传递时，函数内的修改会影响原始变量。

### **嵌套结构体**

Go 中的结构体可以嵌套使用，即一个结构体的字段可以是另一个结构体。

```go
type Address struct {
    City  string
    State string
}

type Person struct {
    Name    string
    Age     int
    Address Address
}
```

使用时：

```go
p := Person{
    Name: "Alice",
    Age:  30,
    Address: Address{
        City:  "New York",
        State: "NY",
    },
}

fmt.Println(p.Address.City) // 输出: New York
```

### 总结

- **`struct` 是 Go 中最常用的复合类型之一** ，它可以将不同类型的数据组合在一起。

- **字段可以有不同的数据类型** ，并且可以通过点号 `.` 来访问。

- **结构体支持嵌入匿名字段** ，可以通过结构体定义更复杂的数据结构。

- **结构体支持方法** ，可以为其定义行为。

- **指针接收者和值接收者** 是 Go 方法的核心，影响结构体方法对字段的修改行为。
  `struct` 提供了一种灵活而强大的方式来构建复杂的数据类型，适合面向数据结构的编程。
