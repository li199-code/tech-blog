---
title: "go 官网教程跟学"
slug: "go -guan-wang-jiao-cheng-gen-xue"
date: 2024-10-01
description: "这里写描述"
tags: [go]
---

go 的官网教程和主流的编程教程网站风格截然不同，应该是没用任何前端框架，纯手糊出来的 ，有一种老式风格的美。

<!-- truncate -->

## 管理模块（module）

新建一个项目后，首先做的是建立一个`go.mod`文件，来管理这个模块。模块即项目。`go.mod`位于项目的根目录。

```
go mod init <moduleName>
```

## 管理包（package）

这里的包可以类比 nodejs 中的库，来自外部。go 只有内置的一种包管理器，不像 node 有那么多选择。导入外部包的步骤是：

1. 先在文件开头写上`import <name>`
2. 运行`go mod tidy`

`go mod tidy`会更新`go.mod` `go.sum`两个文件的依赖信息。

## 错误处理

go 的异常处理机制似乎“臭名昭著”。

```go
message, err := greetings.Hello("fads")
// If an error was returned, print it to the console and
// exit the program.
if err != nil {
    log.Fatal(err)
}
```

也就是说，错误没有传递机制，所以，就要写很多的`if err != nil`。

## 数据结构

### slice

slice 是一种没有预先设定长度的数组，故而比较灵活。

```go
formats := []string{
        "Hi, %v. Welcome!",
        "Great to see you, %v!",
        "Hail, %v! Well met!",
    }
```

### map

map 就是键值对。需要用一个 make 函数来创建。

```go
// 创建
messages := make(map[string]string)
//赋值
messages[name] = message
```

## 测试

go 同样内置了测试机制。创建一个`xxx_test.go`文件。

```go
package greetings

import (
    "testing"
    "regexp"
)

// TestHelloName calls greetings.Hello with a name, checking
// for a valid return value.
func TestHelloName(t *testing.T) {
    name := "Gladys"
    want := regexp.MustCompile(`\b`+name+`\b`)
    msg, err := Hello("Gladys")
    if !want.MatchString(msg) || err != nil {
        t.Fatalf(`Hello("Gladys") = %q, %v, want match for %#q, nil`, msg, err, want)
    }
}

// TestHelloEmpty calls greetings.Hello with an empty string,
// checking for an error.
func TestHelloEmpty(t *testing.T) {
    msg, err := Hello("")
    if msg != "" || err == nil {
        t.Fatalf(`Hello("") = %q, %v, want "", error`, msg, err)
    }
}
```

测试函数用 Test 开头。运行测试用例用`go test <-v>`命令。
